# Let's Play Blackjack
#### Video Demo:  https://youtu.be/Oq415jpi8Hk
#### Description:
A simple blackjack game that will allow users to play on profiles, and save when they are done in case they want to continue.
There are several different classes that are utilized.
##### Player class
The player class tracks the name of the player and the balance of points. It also keeps track of the player's hand, you will you need to manually clear the hand after every hand,  
though there is a function to do this (player.clear_hand()). The player class also implements a function called .save(), which returns the name and balance in a dictionary so that it can be saved in the main file. 
##### Card class   
The card class represents cards in our game and when initialized accepts a suit and  a rank which will determine the card's value. When initialized a card object will also create a pretty print style string for easy printing. 
##### Deck class
The deck class implements the card class and creates a deck of cards that you can use to play any game. This program is specifically blackjack but all of this stuff so far should work with anything else. The deck class also handles shuffling and dealing cards from the deck. For simplicity's sake every hand that is played resets the deck to be a full fifty two card deck.
##### Project.py
Finally we have the main project file. In this file we have the main functionality of our program. It will load player profile data and create a new player object. It also creates a blank user profile for the computer to use as the dealer, though the dealer's point balance is never checked or updated so this may be a bit of a waste. After a profile is either loaded or created the player can play black track against a computer dealer. All the rules for blackjack are in this game except for splitting because I wanted to keep it simple for now(though I want to add this later). After the player's turn the computer dealer will take a turn.  I use a pretty basic decision tree.  the AI will never hit on anything higher than a sixteen because it has a high chance of busting,  and we'll keep trying to get higher than the player until it either busts or succeeds. I want to add something more complicated later.
    If the player runs out of points the computer will just give them a hundred more because there are no actual stakes to this game. After each hand the player is prompted if they want to play again,  yes we'll start the game over again. Card counting won't work because the deck is reset every time. If the player answers no then their profile is automatically saved. 
     There are many helper functions inside of project.py.  print_hands  we'll take both the player object and a dealer object and will print out both hands,  obscuring the dealer's first card unless the optional argument is passed a True. This is so you never know what the dealer has until both hands are evaluated and then printed later. There are also two functions that work as  pretty basic menus. get_menu_selection()  takes two optional arguments one the message you want to provide and the second the amount of answers the user can provide. All menu interaction is done with numbers because it was easier than making a more complex parser. invalid responses are prompted to try again. Name entry is similar. Names must be less than fifteen characters in length and can't contain a new line. When loading a profile the function display_profiles loans data and then displays all of the names that you could pick from to load. With all of the entry stuff I believe I could have made a generic function to handle most menus on top of the selection functions,  but the menus have enough finickiness to them that I wanted to make sure that they all had their own functions.
